#version 330 core

layout (location = 0) out vec4 gColor;
layout (location = 1) out vec4 gExtra;

const float PI  = 3.14159265358979323846264338327950288419716939937510f;

uniform vec3 cam_position;
uniform mat4 myview_matrix;
uniform mat4 mymodel_matrix;
uniform mat3 mynormal_matrix;

in vec2 texCoords;

struct Light {
    int type;
    vec3 position;
    vec3 intensity;	
    vec3 direction;
};

uniform int num_lights;
const int NR_LIGHTS = 32;
uniform Light lights[NR_LIGHTS];

uniform sampler2D gPosition;
uniform sampler2D gAlbedo;
uniform sampler2D gNormal;
uniform sampler2D gEnv;

float saturate(float f)
{
    return clamp(f, 0.0f, 1.0f);
}

float Fd90(float NoL, float roughness)
{
    return (2.0f * NoL * roughness) + 0.4f;
}

float KDisneyTerm(float NoL, float NoV, float roughness)
{
    return (1.0f + Fd90(NoL, roughness) * pow(1.0f - NoL, 5.0f)) * (1.0f + Fd90(NoV, roughness) * pow(1.0f - NoV, 5.0f));
}

vec3 FresnelSchlick(float NdotV, vec3 F0)
{
    return F0 + (1.0f - F0) * pow(1.0f - NdotV, 5.0f);
}

vec3 FresnelRoughness(float NdotV, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - NdotV, 5.0f);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float rough2 = roughness * roughness;
    float rough4 = rough2 * rough2;

    float NdotH = saturate(dot(N, H));
    float NdotH2 = NdotH * NdotH;

    float denom  = (NdotH2 * (rough4 - 1.0) + 1.0);
    denom        = PI * denom * denom;

    return rough4 / denom;
}

float SmithGeometryGGX(float NdotL, float NdotV, float roughness)
{
    float NdotL2 = NdotL * NdotL;
    float NdotV2 = NdotV * NdotV;
    float kRough2 = roughness * roughness + 0.0001f;

    float ggxL = (2.0f * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0f - NdotL2)));
    float ggxV = (2.0f * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0f - NdotV2)));

    return ggxL * ggxV;
}

void main()
{             
    // retrieve data from gbuffer
    vec3 tPosition = texture(gPosition, texCoords).rgb;
    vec3 tAlbedo = texture(gAlbedo, texCoords).rgb;
    vec3 tNormal = texture(gNormal, texCoords).rgb;
    vec4 tEnv = texture(gEnv, texCoords).rgba;

    float roughness = texture(gAlbedo, texCoords).a;
    float metalness = texture(gNormal, texCoords).a;
    float ao = texture(gPosition, texCoords).a;

    vec3 cam = vec3(0.0);

    vec3 V = normalize(cam - tPosition.rgb);
    vec3 N = normalize(tNormal);
    vec3 R = normalize(reflect(-V, N));

    float NdotV = max(dot(N, V), 0.0001f);
    vec3 materialF0 = vec3(0.04f); // for non-metal
    //materialF0 = vec3(1.0f, 0.72f, 0.29f); //gold

    // Fresnel (Schlick) computation (F term)
    vec3 F0 = mix(materialF0, tAlbedo, metalness);
    vec3 F = FresnelRoughness(NdotV, F0, roughness);
    //vec3 F = FresnelSchlick(NdotV, F0);
    // Energy conservation
    vec3 kS = F;
    vec3 kD = vec3(1.0)-kS;
    kD *= 1.0f - metalness;

    vec3 rEnv = F0 * tEnv.rgb * tAlbedo * metalness;
    vec3 color = (metalness > 0.95 && roughness < 0.35)? rEnv:vec3(0.0);
    vec3 diffuse = vec3(0.0f);  vec3 specular = vec3(0.0f);

    for (int i = 0; i < num_lights; i++) // treate them as direction lights
    {
        mat4 dirMatrix = mymodel_matrix * myview_matrix;
        vec4 light_pos = vec4(lights[i].position, 1.0);
        vec3 direction = (dirMatrix * light_pos).rgb;
        vec3 L = normalize(-direction);
        vec3 H = normalize(L + V);

        vec3 lightColor = vec3(0.2);  
        //vec3 lightColor = lights[i].Color.rgb; 
        //colorLinear(lights[i].Color.rgb);

        // Light source dependent BRDF term(s)
        float NdotL = saturate(dot(N, L));
        //diffuse = tAlbedo / PI; // Lambertian
        float kDisney = KDisneyTerm(NdotL, NdotV, roughness);
        diffuse = tAlbedo * kDisney;
        float D = DistributionGGX(N, L, roughness);
        float G = SmithGeometryGGX(NdotL, NdotV, roughness);
        // Specular component computation
        //F = FresnelSchlick(max(dot(H, V), 0.0), F0);

        specular = (D * F * G) / (4.0f * NdotL * NdotV + 0.0001f);
        color += (diffuse * kD + specular) * lightColor * NdotL; 
     }

    vec3 ambient = vec3(0.05) * tAlbedo * ao;
    color += ambient;

    // HDR tonemapping
    color = color / (color + vec3(1.0));
    // gamma correct
    color = pow(color, vec3(1.0/2.2));

    gColor.rgb = color;
    gColor.a = tEnv.a;

    gExtra.rgb = specular;
    gExtra.a = 1.0;
}